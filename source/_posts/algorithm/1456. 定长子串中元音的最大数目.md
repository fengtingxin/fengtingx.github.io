---
title: 1456. 定长子串中元音的最大数目
date: 2024-07-18 22:38:49
categories:
  - 算法
tags:
  - 算法
  - 定长滑动窗口专题
---

给你字符串 `s` 和整数 `k` 。

请返回字符串 `s` 中长度为 `k` 的单个子字符串中可能包含的最大元音字母数。

英文中的 **元音字母** 为（`a`, `e`, `i`, `o`, `u`）。



**示例 1：**

```
输入：s = "abciiidef", k = 3
输出：3
解释：子字符串 "iii" 包含 3 个元音字母。
```

**示例 2：**

```
输入：s = "aeiou", k = 2
输出：2
解释：任意长度为 2 的子字符串都包含 2 个元音字母。
```

**示例 3：**

```
输入：s = "leetcode", k = 3
输出：2
解释："lee"、"eet" 和 "ode" 都包含 2 个元音字母。
```

**示例 4：**

```
输入：s = "rhythms", k = 4
输出：0
解释：字符串 s 中不含任何元音字母。
```

**示例 5：**

```
输入：s = "tryhard", k = 4
输出：1
```

**提示：**

- `1 <= s.length <= 10^5`
- `s` 由小写英文字母组成
- `1 <= k <= s.length`



暴力破解：

```java
class Solution {
    private List<Character> charList = Arrays.asList('a', 'e', 'i', 'o', 'u');
    public int maxVowels(String s, int k) {
        char[] charArray = s.toCharArray();
        int max = 0;
        for(int i =0 ; i < charArray.length; i++){
            if(charList.contains(charArray[i])){
                //依次向后循环
                int temp = 0;
                for(int j = i; j< charArray.length && j < i+k; j++){
                    //
                    if(charList.contains(charArray[j])){
                        temp++;
                    }
                }
                max = Math.max(temp,max);
            }
        }
        return max;
    }
}
```

不出意外，结果超时了，时间复杂度在最坏情况下接近O(n^2)

思考：

由于算法中使用了两层循环，所以在遇到大数据量时，会出现超时的问题。

那么在算法中是否有重复做功呢？

有。即在第二层循环中进行了多次判断。那么怎么减少多次判断的次数呢？

有个想法：举例说明：

leetcode，l不是，则到下一个，e是，则计数加一 等于1，下一个，e是，计数加一 等于2，下一个，t不是，计数减一。

```java
class Solution {
    private List<Character> charList = Arrays.asList('a', 'e', 'i', 'o', 'u');
    public int maxVowels(String s, int k) {
        char[] charArray = s.toCharArray();
        int max = 0;
        //计算前k个对应的结果
        for(int i =0 ; i < k; i++){
            if(charList.contains(charArray[i])){
                max++;
            }
        }

        int result = max;

        for(int i = k ; i < charArray.length; i++){
            //每向后挪一步，都要关注这一步的值是啥，以及之开头一步的值是啥
            //如果后挪一步是，则加一
            //若是前面移除的值是，则减1
            boolean next = charList.contains(charArray[i]);
            boolean start = charList.contains(charArray[i-k]);
            if(next){
                max++;
            }
            if(start){
                max--;
            }
            // System.out.println("current is "+ charArray[i] + "; max = "+ max);
            result = Math.max(result,max);
        }
        return result;
    }
}
```



